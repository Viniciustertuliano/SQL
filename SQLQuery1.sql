--Aula 01 06/02/2020
select getdate()
--Inserindo "---" comentario

/*
Comentario em bloco
selecionar cada programa passo a passo
*/

--Tecla comentario CTRL + KC
--sql serve como SELECT GETDATE(), select getdate() ou SELECT GetDate()
--CTRL + R deixar de exibir o resultado

--Criando o banco de dados

CREATE DATABASE AULA01

--EXPERIMENTANDO AS TABELAS DO
--FIT_ALUNOS

SELECT *
FROM E_EMPRESA

--EXERCICIO: VERIFICAR O REGISTRO DAS TABELA E_EVENTO, E_LOCAL, FABRICANTE E FT_ESTADIO
--QUANTOS REGISTROS CADAS TABELA POSSUI

SELECT *
FROM E_EVENTO
--2 linhas

SELECT *
FROM E_LOCAL
--1 linhas

SELECT *
FROM FABRICANTE
--9 linhas

SELECT *
FROM FT_ESTADIO
--6 linhas

--AULA 02 13/02/2020

--ENTRANDO NO DATABASE

USE master
USE fit_alunos

SELECT *
FROM fit_alunos.dbo.FT_ESTADIO
-- 6 resultados

--CRIANDO TABELAS

CREATE TABLE TB_IMPACTA
(
	NOME_ALUNO CHAR(50)
)

--CONSULTADO A TABELA CRIADA
SELECT *
FROM TB_IMPACTA

--VERIFICANDO A ESTRUTURA DA TABELA

SP_HELP
TB_IMPACTA

---INSERINDO VALORES NA TABELA

INSERT INTO TB_IMPACTA
	(NOME_ALUNO)
VALUES
	('ABNER PORTO'),
	('JAIR PORTO')

SELECT *
FROM TB_IMPACTA

--EXERCICIO AULA 13.02

CREATE TABLE TB_AULA02
(

	CIDADE CHAR(30)

)

INSERT INTO TB_AULA02
	(CIDADE)
VALUES
	('São Paulo'),
	('Rio de Janeiro')

SELECT *
FROM TB_AULA02

--DROP TABLE - EXCLUIR TABELA

/*
CRIANDO UMA TABELA COM CAMPO DE AUTO NUMERAÇÃO E
COM CHAVE PRIMÁRIA.
*/


CREATE TABLE UF
(
	ID_UF INT IDENTITY,
	UF CHAR(30)
)

INSERT INTO UF
	(UF)
VALUES
	('SÃO PAULO'),
	('RIO DE JANEIRO')

SELECT *
FROM UF

-- DELETAR TODOS OS REGISTROS DA TABELA
-- OBS: A CONTAGEM DO ID NÃO É ZERADA, DANDO CONTINUIDADE AO INSERIR NOVOS DADOS.

DELETE UF

-- CRIANDO TABELA COM CHAVE PRIMARIA

CREATE TABLE TB_SI_E_ADS
(

	COD_ALUNO INT,
	NOME_ALUNO CHAR(30)

		-- CONFIGURAÇÃO CHAVE PRIMARIA E RESTRIÇÃO DE DUPLICIDADE
		CONSTRAINT PK_COD_ALUNO PRIMARY KEY (COD_ALUNO)
)

INSERT INTO TB_SI_E_ADS
	(COD_ALUNO, NOME_ALUNO)
VALUES

	(1800074, 'Beltrano')

SELECT *
FROM TB_SI_E_ADS


/*
UML: UNIFYING MODELING LANGUAGE
________________________
|	   TB_CADASTRO     |
________________________
|COD_CLIENTE INT       |
|NOME_CLIENTE CHAR(30) |
|TELEFONE BIGINT	   |
________________________
OBS: COD_CLIENTE (PK)
*/

CREATE TABLE TB_CADASTRO
(
	COD_CLIENTE INT,
	NOME_CLIENTE CHAR(30),
	TELEFONE BIGINT
		-- CHAVE PRIMARIA E RESTRIÇÃO DE DUPLICIDADE
		CONSTRAINT PK_COD_CLIENTE PRIMARY KEY (COD_CLIENTE)
)

INSERT INTO TB_CADASTRO
	(COD_CLIENTE,NOME_CLIENTE,TELEFONE)
VALUES
	(4, 'TESTE', 46578000)


SELECT *
FROM TB_CADASTRO

SP_HELP
TB_CADASTRO

--20/02/2020

--clustered    1.Performance
--unique       2.Não repete
--primary key  3.Abre uma porta para uma foreign key

--non clustered 

--Foreign key

CREATE TABLE TB_FUNC
(
	COD_FUNC INT,
	NOME_FUNC CHAR(30)

		CONSTRAINT PK_FUNC PRIMARY KEY(COD_FUNC)
)

INSERT INTO TB_FUNC
	(COD_FUNC, NOME_FUNC)
VALUES
	(1000, 'JÓSE'),
	(2000, 'MARIA')

CREATE TABLE TB_DEPN
(
	COD_DEPN INT,
	NOME_DEPN CHAR(30),
	COD_FUNC INT

		CONSTRAINT PK_COD_DEPN PRIMARY KEY (COD_DEPN),
	CONSTRAINT FK_COD_FUNC FOREIGN KEY (COD_FUNC)
	REFERENCES TB_FUNC(COD_FUNC)
)

INSERT INTO TB_DEPN
	(COD_DEPN,NOME_DEPN, COD_FUNC)
VALUES
	(1000, 'jOSÉ JUNIOR', 1000),
	(2000, 'MARIO BROS', 2000)
,
--(3000,'ORFÃO',3000)

SELECT *
FROM TB_DEPN

--CRIAR TABELA DE VEICULOS 
--COD_VEIC (PK)	BIGINT
--NOME_VEIC		VARCHAR(50)

--CRIAR TABELA DE MULTAS
--COD_MULTA(PK)		BIGINT
--VALOR_MULTA		MONEY
--COD_VEICULO(FK)	BIGINT

--ESTABELECER RELACIONAMENTO ENTRE AS DUAS TABELAS

CREATE TABLE TB_VEICULOS
(
	COD_VEIC BIGINT,
	NOME_VEIC VARCHAR(30)

		CONSTRAINT PK_COD_VEIC PRIMARY KEY(COD_VEIC)
)

INSERT INTO TB_VEICULOS
	(COD_VEIC, NOME_VEIC)
VALUES
	(1000, 'FOX'),
	(2000, 'GOL')

CREATE TABLE TB_MULTA
(
	COD_MULTA BIGINT,
	VALOR_MULTA MONEY,
	COD_VEIC BIGINT

		CONSTRAINT PK_COD_MULTA PRIMARY KEY (COD_MULTA),
	CONSTRAINT FK_COD_VEIC FOREIGN KEY (COD_VEIC)
	REFERENCES TB_VEICULOS(COD_VEIC)
)

INSERT INTO TB_MULTA
	(COD_MULTA,VALOR_MULTA,COD_VEIC)
VALUES
	(1000, 100.00, 1000),
	(2000, 500.00, 2000)
,
--(3000,350.00,3000)

--CRIAR A ESTRUTURA DE UM RESTAURANTE (CARDÁPIO + COMANDA)
--NA TABELA DE CARDÁPIO, COLOCAR: COD_PRAT + NOME_PRATO + VALOR_PRATO
--NA TABELA DE COMANDA, COLOCAR, COD_PRATO + DATA_PEDIDO
--FORMATO DATA: AAAA-MM-DD

CREATE TABLE TB_CARDAPIO
(
	COD_PRAT INT,
	NOME_PRAT VARCHAR (30),
	VALOR_PRAT MONEY

		CONSTRAINT PK_COD_PRAT PRIMARY KEY(COD_PRAT)
)



INSERT INTO TB_CARDAPIO
	(COD_PRAT,NOME_PRAT,VALOR_PRAT)
VALUES
	(10, 'FEIJOADA', 25.00),
	(20, 'LASANHA', 20.00)

CREATE TABLE TB_COMANDA
(
	COD_PRATO INT,
	DATA_PEDIDO DATE

		CONSTRAINT FK_COD_PRAT FOREIGN KEY(COD_PRATO)
	REFERENCES TB_CARDAPIO(COD_PRAT)

)

INSERT INTO TB_COMANDA
	(COD_PRATO,DATA_PEDIDO)
VALUES
	(10, '2020-02-20'),
	(20, '2020-02-19'),
	(30, '2020-02-19')

SELECT *
FROM TB_COMANDA


--27/02/2020

CREATE TABLE TB_CLIMA
(
	ID_CLIMA INT,
	DESCRIÇÃO CHAR(50)
)

DROP TABLE TB_CLIMA

INSERT INTO TB_CLIMA
	(ID_CLIMA, DESCRIÇÃO)
VALUES
	(2000, '')

SELECT *
FROM TB_CLIMA

CREATE TABLE TB_CLIMA2
(
	ID_CLIMA INT,
	DESCRICAO CHAR(50) NOT NULL
)

INSERT INTO TB_CLIMA2
	(ID_CLIMA , DESCRICAO)
VALUES
	(1000, 'TEMPO GELADO')

INSERT INTO TB_CLIMA2
	( DESCRICAO )
VALUES
	( 'TEMPO MUITO GELADO' )

INSERT INTO TB_CLIMA2
	( ID_CLIMA )
VALUES
	( 3000 )

--EXERCICIO: CRIAR UMA TABELA DE TIMES, CONTENDO OS CAMPOS:
--ID_BID		(CAMPO DE AUTO NUMERAÇÃO)
--CNPJ_TIME		(NÃO ACEITA NULOS)
--NOME_TIME		(NÃO ACEITA NULOS)
--QTD_TITULOS		(ACEITA NULOS)

CREATE TABLE TB_TIMES
(
	ID_BID INT IDENTITY,
	CNPJ_TIME BIGINT NOT NULL,
	NOME_TIME CHAR(20) NOT NULL,
	QTD_TITULOS INT
)

DROP TABLE TB_TIMES


--PRIMEIRO ERRO: TENTAR INSERIR VALOR A COLUNO COM IDENTITY
INSERT INTO TB_TIMES
	(ID_BID, CNPJ_TIME,NOME_TIME, QTD_TITULOS)
VALUES
	(301, 123450001, 'TIME', 3)

--INSERT CORRETO
INSERT INTO TB_TIMES
	(CNPJ_TIME, NOME_TIME, QTD_TITULOS)
VALUES
	(302, 'TIME2', 3)

--SEGUNDO ERRO: TENTAR INSERIR UM VALOR CHAR MAIOR QUE O TAMANHO DO PARAMETRO
INSERT INTO TB_TIMES
	(CNPJ_TIME, NOME_TIME, QTD_TITULOS)
VALUES
	(304, 'KLSJEFGNSKLJERNGOOSERNGSERG' , 3)

--TERCEIRO TIPO DE ERRO: ESTOURO DA VARIÁVEL NUMÉRICA 
INSERT INTO TB_TIMES
	(CNPJ_TIME, NOME_TIME, QTD_TITULOS)
VALUES
	(9223372036854775808, 'SPFC' , 3)

SELECT *
FROM TB_TIMES

--EXERCICIO: APAGAR A TABELA ACIMA E CRIAR COM AS MESMAS CONDIÇÕES,
--ALTERANDO APENAS O CAMPO CNPJ PARA UNIQUE

DROP TABLE TB_TIMES

--EXERCICIO: CRIAR UMA TABELA DE TIMES, CONTENDO OS CAMPOS:
--ID_BID		(CAMPO DE AUTO NUMERAÇÃO)
--CNPJ_TIME		(NÃO ACEITA NULOS) + (CAMPO SEM DUPLICIDADE)
--NOME_TIME		(NÃO ACEITA NULOS)
--QTD_TITULOS		(ACEITA NULOS)

CREATE TABLE TB_TIMES
(
	ID_BID INT IDENTITY,
	CNPJ_TIME BIGINT NOT NULL ,
	NOME_TIME CHAR(20) NOT NULL,
	QTD_TITULOS INT
		CONSTRAINT UQ_TIMES_CNPJ UNIQUE(CNPJ_TIME)
)

--PRIMEIRO ERRO: TENTAR INSERIR VALOR A COLUNO COM IDENTITY
INSERT INTO TB_TIMES
	(ID_BID, CNPJ_TIME,NOME_TIME, QTD_TITULOS)
VALUES
	(301, 123450001, 'TIME', 3)

--INSERT CORRETO
INSERT INTO TB_TIMES
	(CNPJ_TIME, NOME_TIME, QTD_TITULOS)
VALUES
	(302, 'TIME2', 3)

--SEGUNDO ERRO: NÃO É POSSIVEL INSERIR UM ELEMENTO REPETIDO NO CAMPO CNPJ
INSERT INTO TB_TIMES
	(CNPJ_TIME, NOME_TIME, QTD_TITULOS)
VALUES
	(302, 'TIME2', 3)

--TERCEIRO ERRO: TENTAR INSERIR UM VALOR CHAR MAIOR QUE O TAMANHO DO PARAMETRO
INSERT INTO TB_TIMES
	(CNPJ_TIME, NOME_TIME, QTD_TITULOS)
VALUES
	(304, 'KLSJEFGNSKLJERNGOOSERNGSERG' , 3)

--QUARTO ERRO: ESTOURO DA VARIÁVEL NUMÉRICA 
INSERT INTO TB_TIMES
	(CNPJ_TIME, NOME_TIME, QTD_TITULOS)
VALUES
	(9223372036854775808, 'SPFC' , 3)

SELECT *
FROM TB_TIMES

--CONSTRAINT DEFAULT

DROP TABLE TB_TIMES

CREATE TABLE TB_TIMES
(
	ID_BID INT IDENTITY,
	CNPJ_TIME BIGINT NOT NULL ,
	NOME_TIME CHAR(20) NULL DEFAULT 'TRICOLOR',
	QTD_TITULOS INT DEFAULT 150
		CONSTRAINT UQ_TIMES_CNPJ UNIQUE(CNPJ_TIME)
)

INSERT INTO TB_TIMES
	(CNPJ_TIME,QTD_TITULOS)
VALUES
	(302, NULL)

SELECT *
FROM TB_TIMES

SP_HELP
TB_TIMES

--CONSTRAINT CHECK

CREATE TABLE TB_CADASTRO_DATA
(
	CPF BIGINT,
	DATA_CADASTRO DATE,

	CONSTRAINT CK_DATA CHECK (DATA_CADASTRO >= '2020-02-26')
)

INSERT INTO TB_CADASTRO_DATA
	(CPF, DATA_CADASTRO)
VALUES
	(317, '2020-02-01')

--EXERCICIO:
--CRIAR TABELA DE CLIENTES, CONTENDO OS CAMPOS
--1.CPF		(NÃO PERMITE DUPLICIDADE)
--2.NOME		(NÃO PERMITE NULOS)
--3.DATA_NASC	(NÃO PERMITE VALORES ANTERIORES AO ANO 2000)
--4.PROFISSÃO	(CASO NÃO PREENCHA NADA, INSERIR'DBA')


CREATE TABLE TB_CLIENTES
(
	CPF BIGINT,
	NOME VARCHAR(30) NOT NULL,
	PROFISSÃO VARCHAR(25) NULL DEFAULT 'DBA',
	DATA_NASC DATE,


	CONSTRAINT UQ_CLI_CPF UNIQUE(CPF),
	CONSTRAINT CK_DATA_NASC CHECK (DATA_NASC >= '2000-01-01')

)

--INSERT CORRETO 
INSERT INTO TB_CLIENTES
	(CPF, NOME, DATA_NASC, PROFISSÃO)
VALUES
	(48161546800, 'VINICIUS', '2000-02-05', 'MONITOR')

--1° ERRO DE DUPLICIDADE NO CAMPO CPF
INSERT INTO TB_CLIENTES
	(CPF, NOME, DATA_NASC, PROFISSÃO)
VALUES
	(48161546800, 'VINICIUS', '2000-02-05', 'MONITOR')

--2° ERRO DE CAMPO NOME VAZIO 
INSERT INTO TB_CLIENTES
	(CPF, DATA_NASC, PROFISSÃO)
VALUES
	(48161546800, '2000-02-05', 'MONITOR')

--3° ERRO NÃO PERMITE VALORES MENORES QUE 2000 
INSERT INTO TB_CLIENTES
	(CPF, NOME,DATA_NASC, PROFISSÃO)
VALUES
	(48161546900, 'THAYNA', '1999-01-05', 'MONITOR')

--4° ERRO CAMPO PROFISSÃO VAZIO PREENCHA DBA 
INSERT INTO TB_CLIENTES
	(CPF, NOME,DATA_NASC )
VALUES
	(48161567900, 'CECILIA', '2017-01-05')

SELECT *
FROM TB_CLIENTES

USE PEDIDOS

-- COMANDOS DE SELECT
SELECT *
FROM TB_EMPREGADO

-- SELECT UTILIZANDO APENAS AS COLUNAS DESEJADAS
-- + INSERINDO O COMANDO ALIAS
SELECT NOME, SALARIO, DATA_ADMISSAO, 'SANTANDER' AS FUNC
FROM TB_EMPREGADO

SELECT NOME, SALARIO, DATA_ADMISSAO, DATA_NASCIMENTO ,
	GETDATE() AS DATA_REL,
	COD_CARGO
FROM TB_EMPREGADO

-- RETORNANDO APENAS UMA QUANTIDADE "N" DE LINHAS EM UMA CONSULTA
SELECT TOP 10
	NOME, SALARIO, SINDICALIZADO
FROM TB_EMPREGADO

-- RETORNO CONSIDERANDO UMA DETERMINADA ORDEM DE SAÍDA
-- EXEMPLO: RETORNAR OS NOMES EM ORDEM ALFABETICA
SELECT NOME, SALARIO, DATA_ADMISSAO
FROM TB_EMPREGADO
ORDER BY	NOME

-- EXEMPLO: ORDENANDO PELO SALARIO PRIMEIRO E DEPOIS POR NOME
SELECT NOME, SALARIO, DATA_ADMISSAO
FROM TB_EMPREGADO
ORDER BY	SALARIO, NOME

-- ORDENAÇÃO EM ORDEM CRESCENTE E DECRESCENTE
-- SE EU NÃO INSERIR NENHUM COMANDO, O DEFAULT É CRESCENTE
SELECT NOME, SALARIO, DATA_ADMISSAO
FROM TB_EMPREGADO
ORDER BY	SALARIO ASC, NOME ASC

-- ORDENANDO EM ORDEM DECRESCENTE
SELECT NOME, SALARIO, DATA_ADMISSAO
FROM TB_EMPREGADO
ORDER BY	SALARIO DESC, NOME ASC

-- ORDENANDO POR UM CAMPO QUE NÃO ESTÁ NA CLÁUSULA SELECT
SELECT NOME, SALARIO, DATA_ADMISSAO, SINDICALIZADO
FROM TB_EMPREGADO
ORDER BY	SINDICALIZADO

-- CRIANDO RANKINGS NO RETORNO DAS CONSULTAS
-- UM RANKING É A SOMA DE ORDENAÇÃO COM QUANTIDADE DE REGISTROS
-- RETORNADOS. POR EXEMPLO: UM PÓDIUM DE FÓRMULA 1
-- COMO RETORNAR ORDENAÇÃO: ORDER BY
-- COMO RETORNAR OS "N" PRIMEIROS REGISTROS: TOP N
-- OU SEJA, UM RANKING NO SQL É FORMADO POR TOP + ORDER BY
-- EXEMPLO: TRAZER OS 5 FUNCIONÁRIOS COM MENOR SALÁRIO
-- + COMANDO ADICIONAL: WITH TIES
SELECT TOP 8
	--WITH TIES
	NOME, SALARIO, DATA_NASCIMENTO
FROM TB_EMPREGADO
WHERE		SALARIO IS NOT NULL
ORDER BY	SALARIO ASC

-- RETORNANDO REGISTROS DE ACORDO COM UMA CONDIÇÃO
-- CLÁUSULA WHERE
-- + OPERADORES RELACIONAIS ( > , >= , < , <= , = , <> , != )
SELECT *
FROM TB_EMPREGADO
WHERE		CODFUN = 1

SELECT *
FROM TB_EMPREGADO
WHERE		CODFUN <> 1

-- EXEMPLO: RETORNAR FUNCIONÁRIOS QUE POSSUAM SALARIO ACIMA DE 3000
SELECT *
FROM TB_EMPREGADO
WHERE		SALARIO > 3000

-- POSSO COMPARAR UM CAMPO COM OUTRO DA TABELA
SELECT TOP 3
	*
-- * = TODOS OS CAMPOS 
FROM TB_EMPREGADO
WHERE		SALARIO < PREMIO_MENSAL

-- RETORNANDO MULTIPLOS VALORES DE UM MESMO CAMPO EM UMA CLÁUSULA WHERE
-- EXEMPLO: RETORNAR TODOS OS FUNCIONÁRIOS DOS CARGOS 10, 11, 12, 13, 14
-- CLÁUSULA: IN
SELECT *
FROM TB_EMPREGADO
WHERE		COD_CARGO IN ( 10 , 11 , 12 , 13 , 14 )

-- EXEMPLO: RETORNAR OS FUNCIONÁRIOS COM NUM. DEPENDENTES IGUAL A 0 OU 2
SELECT *
FROM TB_EMPREGADO
WHERE		NUM_DEPEND IN ( 0 , 2 )
-- 48 LINHAS DE RETORNO
-- ALTERAR A CONSULTA ACIMA PARA RETORNAR AS DEMAIS CONDIÇÕES
-- TODOS QUE SÃO DIFERENTES DE 0 E DE 2
SELECT *
FROM TB_EMPREGADO
WHERE		NUM_DEPEND NOT IN ( 0 , 2 )
-- 12 LINHAS DE RETORNO

-- ENTENDENDO ONDE ESTÁ O REGISTRO FALTANTE
SELECT *
FROM TB_EMPREGADO
ORDER BY	NUM_DEPEND
-- ESTÁ NO REGISTRO NULO

-- + OPERADORES LÓGICOS ( AND , OR )
-- AND: SOMAR CONDIÇÕES, EXCLUINDO MAIS LINHAS DO RETORNO (OU RESTRINGE)
-- OR:  ALTERNAR CONDIÇÕES, INSERINDO MAIS LINHAS NO RETORNO

-- EXEMPLO: RETORNAR TODOS OS FUNCIONÁRIOS DO CARGO 14 E QUE POSSUAM
-- SALARIO ACIMA DE 2000
SELECT *
FROM TB_EMPREGADO
WHERE		COD_CARGO      = 14
	AND PREMIO_MENSAL  > 500

-- EXEMPLO: RETORNAR TODOS OS FUNCIONÁRIOS QUE SEJAM DO DEPTO MAIOR QUE 5
-- OU QUE SEJAM SINDICALIZADOS
SELECT *
FROM TB_EMPREGADO
WHERE		COD_DEPTO > 5
	OR SINDICALIZADO = 'S'

-- AULA 02 ABRIL 2020...

-- IMPORTANDO UM BANCO DE DADOS
USE PEDIDOS

-- OPERADORES AULA PASSADA: RELACIONAIS (> , < ... ) E LÓGICOS (AND E OR)

-- OPERADORES DESTA AULA: OPERADORES MATEMÁTICOS ( + , - , / ,  * )
SELECT TOP 3
	*
FROM TB_EMPREGADO

-- EXEMPLO: SOMAR UM DETERMINADO VALOR (500) NO CAMPO PREMIO_MENSAL
SELECT TOP 10
	NOME, PREMIO_MENSAL, PREMIO_MENSAL + 500 AS NOVO_PREMIO_MENSAL
FROM TB_EMPREGADO

-- EXEMPLO: SUBSTRAIR 100 NO SALARIO DE TODOS OS FUNCIONÁRIOS DO COD_CARGO > 10
SELECT NOME, SALARIO, SALARIO - 100 AS NOVO_SALARIO, COD_CARGO
FROM TB_EMPREGADO
WHERE		COD_CARGO > 10

-- EXERCICIO: DAR AUMENTO DE 10% EM TODOS OS FUNCIONÁRIOS QUE SEJAM SINDICALIZADOS
-- DICA: VARIÁVEL + (VARIÁVEL * 0.10) OU VARIÁVEL * 1.10
SELECT TOP 3
	*
FROM TB_EMPREGADO
WHERE SALARIO = 600

SELECT NOME, SALARIO, SINDICALIZADO,
	SALARIO + (SALARIO * 0.10)	AS NOVO_SAL01,
	SALARIO * 1.10				AS NOVO_SAL02
FROM TB_EMPREGADO
WHERE			SINDICALIZADO = 'S'

-- UTILIZANDO WHERE COM MÚLTIPLAS CONDIÇÕES
-- EXEMPLO DE CONDIÇÃO: CAMPO DE DATA
SELECT *
FROM TB_PEDIDO
ORDER BY DATA_EMISSAO
-- BUSCAR PEDIDOS COM DATA DE EMISSÃO NO ANO DE 2014
SELECT *
FROM TB_PEDIDO
WHERE		DATA_EMISSAO >= '2014-01-01'-- FORMATO DE DATA NO SQL: 'AAAA-MM-DD'
	AND DATA_EMISSAO <= '2014-12-31'
-- COMANDO BETWEEN: SELECIONA UMA RANGE DE VALORES ENTRE O LIMITE 01 E O LIMITE 02
SELECT *
FROM TB_PEDIDO
WHERE		DATA_EMISSAO BETWEEN '2014-01-01' AND '2014-12-31'
-- FUNÇÕES DE DATA: SEPARAR ELEMENTOS DE UM CAMPO DE DATA
-- YEAR(CAMPO): RETORNA O VALOR DO ANO DE UMA DATA
SELECT *
FROM TB_PEDIDO
WHERE		YEAR(DATA_EMISSAO) = 2014

-- EXERCICIO: BUSCAR OS PEDIDOS COM VALORES ENTRE 500 E 1500 REAIS E QUE SEJAM PRIMEIRO SEMESTRE DE 2014
SELECT *
FROM TB_PEDIDO
WHERE		VLR_TOTAL >= 500 AND VLR_TOTAL <= 1500
	--			VLR_TOTAL BETWEEN 500 AND 1500
	AND DATA_EMISSAO BETWEEN '2014-01-01' AND '2014-06-30'

SELECT *
FROM TB_PEDIDO
WHERE	DATA_EMISSAO >= '2014-01-01' -- O FORMATO PODE SER: AAAA-DD-MM (FORMATO AMERICANO)
	AND DATA_EMISSAO <= '2014-12-31'

SELECT *
FROM TB_PEDIDO
WHERE	DATA_EMISSAO BETWEEN '2014-01-01' AND '2014-12-31'

-- FUNÇÕES DE DATA: SEPARAR ELEMENTOS DE UM CAMPO DE DATA
-- YEAR(CAMPO):	RETORNA O VALOR DO ANO DE UMA DATA
-- MONTH(CAMPO):	RETORNA O VALOR DO MÊS DE UMA DATA
-- DAY(CAMPO):		RETORNA O VALOR DO DIA DE UMA DATA

-- UTILIZANDO O EXEMPLO DO EXERCICIO ABAIXO
-- EXERCICIO: BUSCAR OS PEDIDOS COM VALORES ENTRE 500 E 1500 REAIS E QUE SEJAM PRIMEIRO SEMESTRE DE 2014
SELECT *
FROM TB_PEDIDO
WHERE			VLR_TOTAL BETWEEN 500 AND 1500
	AND YEAR(DATA_EMISSAO) = 2014
	AND MONTH(DATA_EMISSAO) IN ( 01 , 02, 03, 04, 05, 06 )


-- BUSCANDO EM VARIÁVEIS DO TIPO CHAR E VARCHAR
-- E
-- BUSCA POR APROXIMAÇÃO
SELECT *
FROM TB_EMPREGADO
WHERE		SINDICALIZADO = 'S'

-- COMO RETORNAR OS INTEGRANTES DA FAMILIA SILVA
-- EXEMPLO CLÁSSICO: CENTRAL DE ATENDIMENTO, BUSCAR O NOME ENQUANTO FALA COM O CLIENTE

SELECT *
FROM TB_EMPREGADO
WHERE			NOME = 'JOSE REIS'

-- E SE EU QUISESSE BUSCAR TODOS OS NOMES QUE COMECEM COM "JOSE"
-- COMANDO OU EXPRESSÃO: LIKE (BUSCA POR APROXIMAÇÃO NO SQL)
-- CARACTERE PERCENTUAL NO LIKE, SERVE COMO CORINGA, ELE IGNORA O QUE VEM ANTES OU DEPOIS DELE...
SELECT *
FROM TB_EMPREGADO
WHERE			NOME LIKE 'JOSE%'
-- E SE EU QUISESSE BUSCAR POR TODAS AS PESSOAS QUE O NOME TENHA JOSE EM QUALQUER PARTE DELE
SELECT *
FROM TB_EMPREGADO
WHERE			NOME LIKE '%JOSE%'
-- COMO RETORNAR OS INTEGRANTES DA FAMILIA SILVA
SELECT *
FROM TB_EMPREGADO
WHERE			NOME LIKE '%silv%'
-- EXEMPLO: RETORNAR TODOS OS FUNCIONARIOS QUE TENHAM A LETRA "A" NO NOME SEGUIDA DE "B" EM QUALQUER PARTE DELE
SELECT *
FROM TB_EMPREGADO
WHERE			NOME LIKE '%A%Z%'
-- ESTANDO EM MAIÚSCULA OU MINÚSCULA, O SQL INTERPRETA DE QQ FORMA. POIS ELE NÃO É CASE SENSITIVE
-- EXERCICIO: BUSCAR TODOS OS INTEGRANTES DA FAMILIA SOUZA (CONSIDERAR TAMBÉM SE O NOME ESTIVER COM S: SOUSA)
SELECT *
FROM TB_EMPREGADO
WHERE			NOME LIKE '%SOUZA%'
	OR NOME LIKE '%SOUSA%'

-- QUANDO EU TENHO UMA CONDIÇÃO ONDE EXISTE LISTA DE VARIÁVEIS DENTRO DE UM NOME (SOU"S"A OU SOU"Z"A)
-- EU POSSO UTILIZAR OS CARACTERES DE COLCHETE (OPCÕES DENTRO DO LIKE)
SELECT *
FROM TB_EMPREGADO
WHERE			NOME LIKE '%SOU[SZ]A%'

-- DESAFIO PARA VOCÊS: LISTAR TODOS OS NOMES QUE COMECEM COM VOGAIS
@NOME CHAR
(30)

SELECT *
FROM TB_EMPREGADO
WHERE	NOME LIKE @NOME

-- VISA:	4...-....-....-....
-- MASTER:	5...-....-....-....

-- LIKE: BUSCA APROXIMADA DE CARACTERES OU BUSCA POSICIONAL...

-- EXEMPLO DE DÚVIDA: PODERIA SER ASSIM? NÃO!
SELECT *
FROM TB_EMPREGADO
WHERE	NOME LIKE '%A%E%I%O%U%'

-- ÚNICO CASO EM QUE RETORNARIA ALGO NESTA CONSULTA
INSERT INTO TB_EMPREGADO
	( NOME )
VALUES
	('JANA ESPERIDIAO OMENA ULRICH')

-- EXERCÍCIOS

-- AULA 09 DE ABRIL DE 2020

-- TRABALHANDO COM VARIÁVEIS DE TEXTO, EXPLORANDO AS FUNÇÕES

-- 6 TIPOS DE FUNÇÕES PARA MANIPULAÇÃO DE TEXTO 

-- NO EXCEL, FÓRMULA ESQUERDA: RETORNA OS "N" DIGITOS A ESQUERDA DE UM CAMPO CHAR OU VARCHAR

-- NO SQL, LEFT(CAMPO , N): RETORNA OS "N" DIGITOS A ESQUERDA DE UM CAMPO CHAR OU VARCHAR

-- EXEMPLO: RETORNAR OS 10 DIGITOS A ESQUERDA DO CAMPO NOME DA TABELA DE EMPREGADOS
USE MASTER
USE PEDIDOS

SELECT LEFT(NOME , 10) AS '10_A_ESQUERDA' , NOME
FROM TB_EMPREGADO

-- RIGHT(CAMPO , N): RETORNA OS "N" DIGITOS A DIREITA DE UM CAMPO CHAR OU VARCHAR
SELECT RIGHT(NOME , 10) AS '10_A_DIREITA' , NOME
FROM TB_EMPREGADO
--WHERE			NOME LIKE '%FABIANO%'

-- 123456789

INSERT INTO TB_EMPREGADO
	( NOME )
VALUES
	( 'FABIANO 123456789' )

-- NECESSIDADE: RETORNAR CARACTERES DO MEIO DA MINHA VARIÁVEL OU DO MEU CAMPO
--'FABIANO ROMEU HENRY PASSOS'

-- EXEMPLO: RETORNAR DA POSIÇÃO 5 ATÉ A POSIÇÃO 10 DE UM CAMPO DE NOME

SELECT TOP 1
	*
FROM TB_FORNECEDOR

-- SUBSTRING(CAMPO , POS-INI , QTDE_CARACTERES): RETORNAR DO CAMPO, A QTDE DE CARACTERES ESPECIFICADA, PARTINDO DA POSIÇÃO
-- INICIAL

SELECT SUBSTRING('FABIANO ROMEU HENRY PASSOS', 5 , 5),
	'FABIANO ROMEU HENRY PASSOS'

--123456789012345678901234567890
--FABIANO ROMEU HENRY PASSOS	

-- EXEMPLO: RETORNAR DA POSIÇÃO 5 ATÉ A POSIÇÃO 10 DE UM CAMPO DE NOME
SELECT NOME,
	SUBSTRING(NOME , 5 , 6) AS NOME_NO_MEIO,
	CNPJ
FROM TB_FORNECEDOR

-- CONTANDO...
--123456789012345678901234567890
--CADIUM COMERCIO IMP.E EXP. LTDA.

--UM COM

-- LEN(CAMPO) OU LENGHT(CAMPO): RETORNA A QUANTIDADE DE CARACTERES EXISTENTES EM UM DETERMINADO CAMPO

SELECT LEN('FABIANO H')

SELECT NOME, LEN(NOME) AS COMPRIMENTO
FROM TB_EMPREGADO

--OLAVO TRINDADE

SP_HELP
TB_EMPREGADO

-- LEFT(CAMPO , N)
-- RIGHT(CAMPO , N)
-- SUBSTRING(CAMPO , POS-INI , QTDE_CARAC)
-- LEN(CAMPO)

-- CONCATENANDO TEXTOS...
-- CONCAT( CAMPO1, CAMPO2, CAMPO3, ... , CAMPON)

-- EXEMPLO: CONCATENAR O VALOR "AAAA" NO CAMPO NOME DA TABELA DE EMPREGADOS

SELECT CONCAT('AAAA' , NOME)
FROM TB_EMPREGADO

-- EXEMPLO: CONCATENAR O NOME E O NOME_FANTASIA DA TABELA DE FORNECEDORES

SELECT CONCAT(NOME , NOME_FANTASIA) AS NOVO_NOME, NOME , NOME_FANTASIA
FROM TB_FORNECEDOR

-- ÍNDICE DO CARACTERE: CHARINDEX(VALOR, CAMPO)

-- LOCALIZAR A POSIÇÃO DO @ DENTRO DO MEU EMAIL
SELECT 'fabiano.passos@ymail.com'
-- POSIÇÃO 15

SELECT CHARINDEX('@', 'fabiano.passos@ymail.com')

-- EXEMPLO: LOCALIZAR A POSIÇÃO DO VALOR "SILVA"
SELECT NOME , CHARINDEX('SILVA', NOME) AS POSICAO_SILVA
FROM TB_EMPREGADO
WHERE			NOME LIKE '%SILVA%'

-- EXERCICIOS DE FIXAÇÃO 

USE PEDIDOS

/*
1. TRAZER TODOS OS FUNCIONÁRIOS DOS CARGOS 10, 14 E 15 OU OS FUNCIONÁRIOS QUE 
   POSSUAM SALÁRIO ACIMA DE 3000

2. TRAZER TODOS OS FUNCIONÁRIOS QUE GANHEM MENOS QUE 1000
   E TAMBÉM OS FUNCIONÁRIOS QUE GANHEM MAIS DO QUE 4000

3. TRAZER TODOS OS FUNCIONÁRIOS QUE ESTEJAM NOS CARGOS
   10 E 14 E TAMBÉM OS FUNCIONÁRIOS COM SALARIO ACIMA DE 5000

4. SOMAR R$ 500,00 NO SALÁRIO DE TODOS OS FUNCIONÁRIOS E INCREMENTAR
   O PREMIO_MENSAL EM 30%

5. RETORNAR OS REGISTROS DE DE VENDA DO CÓDIGO 01 EM JANEIRO DE 2014
-- TABELA: TB_PRODUTO

6. LISTAR TODOS OS FORNECEDORES QUE POSSUAM NO NOME, O CONTEÚDO "LTDA"
--TB_FORNECEDOR 

7. TRAZER OS FORNECEDORES DO ESTADO DE SÃO PAULO, COM CODIGO DO FORNEDOR SUPERIOR 
   A 500 E QUE POSSUAM "FERR" NO NOME

8. RETORNAR OS CLIENTES QUE POSSUAM BAIRRO NULO
--TB_CLIENTE

9. TRAZER OS NOMES E NOMES FANTASIA CLIENTES DO SUDESTE (COLUNA ESTADO) + APENAS
   A PARTE DO ANO DA DATA DE CADASTRO

10. 

A. RETORNAR, UTILIZANDO RANKEAMENTO (ORDER BY + TOP), O FUNCIONÁRIO MAIS VELHO DE EMPRESA

B. RETORNAR, UTILIZANDO RANKEAMENTO (ORDER BY + TOP), O FUNCIONÁRIO MAIS NOVO DE IDADE

-- VARIÁVEIS DE TEXTO

11. RETORNAR OS 5 CARACTERES DA ESQUERDA DO CAMPO NOME DA TABELA DE CLIENTES

12. DESCOBRIR A POSIÇÃO DA VARIÁVEL "SILV" NO CAMPO NOME DA TABELA DE EMPREGADOS

13. CONCATENAR OS TRÊS PRIMEIROS DÍGITOS DO NOME DOS EMPREGADOS COM A POSIÇÃO 5 A 8 
    DO MESMO NOME, APENAS PARA OS COLABORADORES DE CARGOS ACIMA DE 10

14. RETORNAR O CNPJ DO FORNECEDOR EM FORMATO 'XX.XXX.XXX/XXXX-XX'
    APENAS PARA OS CNPJS QUE POSSUIREM 14 DE TAMANHO NESTE CAMPO

15. DESAFIO: TROCAR TODOS OS "SILV" POR "RODRIGUES" NA TABELA DE EMPREGADOS

*/

SELECT *
FROM TB_EMPREGADO
WHERE COD_CARGO IN (10, 14, 15) OR
	SALARIO >= 3000

SELECT *
FROM TB_EMPREGADO
WHERE		SALARIO < 1000
	OR SALARIO > 4000

SELECT *
FROM TB_EMPREGADO
WHERE COD_CARGO IN (10, 14)
	OR SALARIO >= 5000

SELECT NOME, SALARIO, SALARIO + 500 AS NOVO_SALARIO, PREMIO_MENSAL, (PREMIO_MENSAL * 0.3)+PREMIO_MENSAL AS NOVO_PREMIO_MENSAL
FROM TB_EMPREGADO

SELECT *
FROM TB_PRODUTO
WHERE COD_TIPO = 1

SELECT *
FROM TB_FORNECEDOR
WHERE			NOME
	 LIKE			'%LTDA%'

SELECT *
FROM TB_FORNECEDOR
WHERE		ESTADO = 'SP'
	AND COD_FORNECEDOR >= 500
	AND NOME LIKE '%FERR%'

SELECT *
FROM TB_CLIENTE
WHERE		BAIRRO IS NULL

SELECT NOME, FANTASIA
FROM TB_CLIENTE
WHERE		ESTADO IN ('SP', 'MG', 'RJ', 'ES')

SELECT TOP 1
	NOME, DATA_NASCIMENTO
FROM TB_EMPREGADO
WHERE		DATA_NASCIMENTO IS NOT NULL
ORDER BY DATA_NASCIMENTO ASC

SELECT TOP 1
	NOME, DATA_NASCIMENTO
FROM TB_EMPREGADO
WHERE		DATA_NASCIMENTO IS NOT NULL
ORDER BY DATA_NASCIMENTO DESC

SELECT LEFT(NOME,5)
	 AS				NOME_ESQUERDA, NOME
FROM TB_CLIENTE

SELECT NOME , CHARINDEX('SILV', NOME) 
	 AS				POSICAO_SILV
FROM TB_EMPREGADO
WHERE		NOME LIKE '%SILV%'

SELECT NOME, CONCAT(LEFT(NOME,3),SUBSTRING (NOME, 5, 8)) 
	 AS				CONCAT_NOME
FROM TB_EMPREGADO
WHERE		COD_CARGO >= 10

SELECT SUBSTRING (CNPJ,1,2) + '.'
	 + SUBSTRING (CNPJ,3,3) + '.'
	 + SUBSTRING (CNPJ,6,3) + '/'
	 + SUBSTRING (CNPJ,9,4) + '-'
	 + SUBSTRING (CNPJ, 13,2)
FROM TB_FORNECEDOR
WHERE LEN(CNPJ) = 14

SELECT
	REPLACE	(NOME, 'SILVA', 'RODRIGUES') AS NOVO_NOME
FROM TB_EMPREGADO

-- aula dia 16-04-2020

-- DICA 0: SEMPRE QUE EU FOR CONCATENAR, EU PRIMEIRO SEPARO AS COLUNAS QUE IREI UNIR
-- DICA 1: DIVIDIR O NOME EM 3 BLOCOS
-- A. O QUE VIER ANTES DO SILV
-- B. A PARTE DO 'SILV' QUE IREI TROCAR POR 'RODRIGUES'
-- C. O QUE VIER DEPOIS DO SILV
-- DICA 2: IR RODANDO A QUERY A CADA PASSO QUE EU DOU
use pedidos

SELECT NOME,
	CHARINDEX('SILV', NOME)																			AS POSICAO_SILV,
	LEFT(NOME, CHARINDEX('SILV', NOME) - 1 )										AS ANTES_SILV,
	CHARINDEX('SILV', NOME)	+ 4																	AS POSICAO_APOS_SILV,
	SUBSTRING(NOME, CHARINDEX('SILV', NOME)	+ 4 , 30)						AS APOS_SILV,

	CONCAT (	LEFT(NOME, CHARINDEX('SILV', NOME) - 1 ) ,
						'RODRIGUES' ,
						SUBSTRING(NOME, CHARINDEX('SILV', NOME)	+ 4 , 30)
					) 																											AS NOME_APOS_ALTERACAO
-- SUBSTRING (CAMPO, POS-INI, QTDE_CARACTERES)
FROM TB_EMPREGADO
WHERE		NOME LIKE '%SILV%'

--ATIVIDADE DE PRESENÇA - AULA DIA 16-04
-- TROCAR TODOS O PRIMEIRO NÚMERO "8" QUE VOCÊ ENCONTRAREM NO CNPJ DO FORNECEDOR PELA LETRA "X"
SELECT CNPJ,
	CHARINDEX('8', CNPJ)																				AS POSICAO_8,
	LEFT(CNPJ, CHARINDEX('8', CNPJ) - 1 )												AS ANTES_8,
	CHARINDEX('8', CNPJ)	+ 1																		AS POSICAO_APOS_8,
	SUBSTRING(CNPJ, CHARINDEX('8', CNPJ)	+ 1 , 30)							AS APOS_8,
	CONCAT (	LEFT(CNPJ, CHARINDEX('8', CNPJ) - 1 ) ,
											'X' ,
						SUBSTRING(CNPJ, CHARINDEX('8', CNPJ)	+ 1 , 30)
					) 																											AS NOME_APOS_ALTERACAO
FROM TB_FORNECEDOR
WHERE			CNPJ LIKE '%8%'
-- TROCAR A PALAVRA "LTDA" PELA EXPRESSÃO "SOCIEDADE ANÔNIMA" NO NOME DO FORNECEDOR
SELECT NOME,
	CHARINDEX('LTDA', NOME)																			AS POSICAO_LTDA,
	LEFT(NOME, CHARINDEX('LTDA', NOME) - 1 )										AS ANTES_LTDA,
	CHARINDEX('LTDA', NOME)	+ 4																	AS POSICAO_APOS_LTDA,
	SUBSTRING(NOME, CHARINDEX('LTDA', NOME)	+ 4 , 30)						AS APOS_LTDA,

	CONCAT (	LEFT(NOME, CHARINDEX('LTDA', NOME) - 1 ) ,
						'SOCIEDADE ANÔNIMA' ,
						SUBSTRING(NOME, CHARINDEX('LTDA', NOME)	+ 4 , 30)
					) 																											AS NOME_APOS_ALTERACAO
--SUBSTRING (CAMPO, POS-INI, QTDE_CARACTERES)
FROM TB_FORNECEDOR
WHERE		NOME LIKE '%LTDA%'

-- 1. DESCOBRIR A POSIÇÃO DO SILV	--> OK
-- 2. ANTES DO SILV					--> OK
-- 3. APÓS O SILV					--> OK
-- 4. CONCATENAR					--> OK

SELECT *
FROM TB_FORNECEDOR




-- CONTEÚDO NOVO: TRATAMENTO DE NULOS

--UTILIZANDO O EXERCÍCIO: "RETORNAR OS CLIENTES QUE POSSUAM BAIRRO NULO" [TB_CLIENTE]
SELECT NOME, BAIRRO
FROM TB_CLIENTE
WHERE		BAIRRO IS NULL

-- COALESCE(CAMPO, <VALOR-ESPECIFICADO>):	VERIFICA SE O CONTEÚDO É NULO E SE FOR, RETORNA O VALOR ESPECIFICADO,
--											CASO NÃO SEJA NULO, RETORNA O PRÓPRIO VALOR DO CAMPO
SELECT NOME,
	BAIRRO,
	COALESCE(BAIRRO, 'BAIRRO É NULO') AS BAIRRO_TRATADO,
	CEP,
	COALESCE(CEP, 'CEP É NULO') AS CEP_TRATADO
FROM TB_CLIENTE
WHERE		BAIRRO IS NULL

-- AULA 30 DE ABRIL DE 2020

-- INFORMAÇÕES GERAIS SOBRE ACs

-- FUNÇÕES DE AGRUPAMENTO/AGREGAÇÃO: SUMARIZAÇÃO DE CAMPOS 

-->  SUM(CAMPO): APRESENTA A SOMA DE VALORES DE UM DETERMINADO CAMPO E POSSIBILITA O AGRUPAMENTO
--               A PARTIR DE UMA RELAÇÃO DE PARÂMETROS
USE PEDIDOS

-- EXEMPLO: SABER O TOTAL GASTO COM SALÁRIOS NESTA EMPRESA
SELECT SUM(SALARIO) AS TOTAL_SALARIO
FROM TB_EMPREGADO

-- EXERCICIO: SOMAR O TOTAL DE PREMIOS_MENSAIS APENAS ONDE OS EMPREGADOS SEJAM SINDICALIZADOS
SELECT SUM(PREMIO_MENSAL) AS TOTAL_PREMIO_MENSAL
FROM TB_EMPREGADO
WHERE	SINDICALIZADO = 'S'

-- EXEMPLO: SOMAR O TOTAL DE SALARIOS POR CARGO
SELECT SUM(SALARIO)	AS TOTAL_SALARIO,
	COD_CARGO
FROM TB_EMPREGADO
GROUP BY	COD_CARGO

-- EXERCICIO: QUERO SABER O TOTAL VENDIDO POR VENDEDOR
SELECT SUM(VLR_TOTAL)	AS TOTAL_VENDA
		, CODVEN
FROM TB_PEDIDO
GROUP BY	CODVEN
ORDER BY	TOTAL_VENDA

-- FUNÇÕES DE AGRUPAMENTO/AGREGAÇÃO: SUMARIZAÇÃO DE CAMPOS 

-->  SUM(CAMPO): APRESENTA A SOMA DE VALORES DE UM DETERMINADO CAMPO E POSSIBILITA O AGRUPAMENTO
--               A PARTIR DE UMA RELAÇÃO DE PARÂMETROS

-->  COUNT(CAMPO): REALIZA A CONTAGEM DE VALORES OU DE LINHAS RETORNADAS. TAMBÉM POSSIBILITA O AGRUPAMENTO
--                 A PARTIR DE UMA RELAÇÃO DE PARÂMETROS

SELECT *
FROM TB_DEPARTAMENTO

SELECT COUNT(COD_DEPTO) AS QTDE_DEPARTAMENTOS
FROM TB_DEPARTAMENTO

-- EXEMPLO: RELACIONAR A QUANTIDADE DE FORNECEDORES POR ESTADO

SELECT ESTADO,
	COUNT(ESTADO)  AS TOTAL_POR_ESTADO
FROM TB_FORNECEDOR
GROUP BY	ESTADO
ORDER BY	ESTADO

SELECT *
FROM TB_FORNECEDOR
WHERE	ESTADO = 'MG'

SELECT COUNT(*)
FROM TB_EMPREGADO
SELECT *
FROM TB_EMPREGADO
WHERE COD_DEPTO IS NOT NULL

-- DICA:	QUANDO PRECISAR SABER SE TEM OU NÃO NULOS EM UM DETERMINADO CAMPO, UTILIZAR O COUNT(CAMPO)
--			QUANDO PRECISAR SABER APENAS A QUANTIDADE DE LINHAS, UTILIZAR O COUNT(*)

-- EXERCICIO: SABER A QUANTIDADE DE PROFISSIONAIS E O TOTAL DE SALÁRIOS POR CARGO
-- COUNT(*) + SUM(CAMPO)
SELECT COUNT(*)		AS QTDE_PROFISSIONAIS,
	SUM(SALARIO)	AS TOTAL_SALARIO,
	COD_CARGO
FROM TB_EMPREGADO
GROUP BY	COD_CARGO

-- EXERCICIO: UMA VEZ QUE EU TENHO O TOTAL GASTO E A QUANTIDADE, CALCULAR A MÉDIA EM UM CAMPO APARTADO

SELECT COUNT(*)								AS QTDE_PROFISSIONAIS,
	SUM(SALARIO)						AS TOTAL_SALARIO,
	SUM(SALARIO) / COUNT(*) AS MEDIA_SALARIAL		,
	COD_CARGO
FROM TB_EMPREGADO
GROUP BY	COD_CARGO

-->  SUM(CAMPO): APRESENTA A SOMA DE VALORES DE UM DETERMINADO CAMPO E POSSIBILITA O AGRUPAMENTO
--               A PARTIR DE UMA RELAÇÃO DE PARÂMETROS

-->  COUNT(CAMPO): REALIZA A CONTAGEM DE VALORES OU DE LINHAS RETORNADAS. TAMBÉM POSSIBILITA O AGRUPAMENTO
--                 A PARTIR DE UMA RELAÇÃO DE PARÂMETROS

-->  AVG(CAMPO): CALCULA A MÉDIA DE UM DETERMINADO CAMPO, POSSIBILITANDO AGRUPAMENTO

-- EXEMPLO: CALCULAR A MÉDIA SALARIAL DOS EMPREGADOS EM UM CAMPO APARTADO

SELECT COUNT(*)					AS QTDE_PROFISSIONAIS,
	SUM(SALARIO)			AS TOTAL_SALARIO,
	AVG(SALARIO)			AS MEDIA_SALARIAL,
	COD_CARGO
FROM TB_EMPREGADO
GROUP BY	COD_CARGO

-- EXERCICIO: RETORNAR A MÉDIA DE VALOR (PR_UNITARIO) POR SITUACAO

SELECT AVG(PR_UNITARIO)		AS MEDIA_PRECO
			, SITUACAO
			, NUM_PEDIDO
FROM TB_ITENSPEDIDO
GROUP BY		SITUACAO, NUM_PEDIDO
/*
Posso trazer campos que não estao sendo agrupados pelo AVG, COUNT, SUM? 
Por exemplo trazer o NUM_PEDIDO, NUM_ITEM nessa query...

R. SÓ PODE TRAZER MAIS CAMPOS, QUANDO A NECESSIDADE DE AGRUPAMENTO FOR DUPLA, TRIPLA
EXEMPLO: AGRUPAR OS SALARIOS, POR CARGO E DEPARTAMENTO (STAND BY)


Professor pode trocar o null por nao pago?
*/
SELECT AVG(PR_UNITARIO)					AS MEDIA_PRECO
			, COALESCE ( SITUACAO , 'NÃO PAGO' )	AS SITUACAO

FROM TB_ITENSPEDIDO
GROUP BY		SITUACAO

-- AGRUPAMENTOS POR MAIS DE UM CAMPO, OU MAIS DE UM PARÂMETRO

SELECT *
FROM TB_EMPREGADO

-- EXEMPLO: DETERMINAR A SOMA DE SALÁRIOS POR CARGO E POR SITUACAO SINDICAL
SELECT SUM(SALARIO)		AS TOTAL_SALARIO,
	COD_CARGO,
	SINDICALIZADO
FROM TB_EMPREGADO
GROUP BY	COD_CARGO,
			SINDICALIZADO
ORDER BY	COD_CARGO,
			SINDICALIZADO

-- EXERCICIO: RETORNAR A MÉDIA DE PREMIO "POR" CARGO E DEPARTAMENTO
SELECT AVG(PREMIO_MENSAL)		AS MEDIA_PREMIO,
	COD_CARGO,
	COD_DEPTO
FROM TB_EMPREGADO
GROUP BY	COD_CARGO, COD_DEPTO
ORDER BY	COD_CARGO


-->  SUM(CAMPO): APRESENTA A SOMA DE VALORES DE UM DETERMINADO CAMPO, POSSIBILITANDO O AGRUPAMENTO
-->  COUNT(CAMPO): REALIZA A CONTAGEM DE VALORES OU DE LINHAS RETORNADAS. TAMBÉM POSSIBILITANDO O AGRUPAMENTO
-->  AVG(CAMPO): CALCULA A MÉDIA DE UM DETERMINADO CAMPO, POSSIBILITANDO AGRUPAMENTO
-->  MIN(CAMPO): RETORNA O MÍNIMO VALOR DE UM DETERMINADO CAMPO. DESCONSIDERANDO OS NULOS
-->  MAX(CAMPO): RETORNA O MÁXIMO VALOR DE UM DETERMINADO CAMPO. DESCONSIDERANDO OS NULOS

-- EXEMPLO: DESCOBRIR QUAL O PREMIO_MENSAL MAIS BAIXO DA TABELA
SELECT *
FROM TB_EMPREGADO
ORDER BY	PREMIO_MENSAL ASC

SELECT MIN(PREMIO_MENSAL) AS PREMIO_MINIMO
FROM TB_EMPREGADO

-- EXEMPLO: VERIFICAR QUAL A VENDA MAIS ALTA DA TABELA DE PEDIDOS
SELECT MAX(VLR_TOTAL) AS MAIOR_PEDIDO
FROM TB_PEDIDO

-- EXERCICIOS: 
-- 1. RETORNAR A DATA DO FUNCIONÁRIO MAIS VELHO DE EMPRESA - OU SEJA, CONTRATADO A MAIS TEMPO
SELECT MIN(DATA_ADMISSAO)	AS MAIS_ANTIGA_CONTRATACAO
FROM TB_EMPREGADO
-- 1980-01-01 00:00:00.000

-- SABER QUEM É:
SELECT *
FROM TB_EMPREGADO
WHERE DATA_ADMISSAO = '1980-01-01'


-- 2. RETORNAR A DATA DO FUNCIONÁRIO MAIS NOVO DA EMPRESA - OU SEJA, NASCIDO A MENOS TEMPO
SELECT MAX(DATA_NASCIMENTO) AS MAIS_NOVO_DE_IDADE
FROM TB_EMPREGADO
-- 2006-02-21 00:00:00.000

-- SABER QUEM É:
SELECT *
FROM TB_EMPREGADO
WHERE DATA_NASCIMENTO = '2006-21-02'

-- SUBSELECT:
SELECT *
FROM TB_EMPREGADO
WHERE DATA_NASCIMENTO = ( 
							SELECT MAX(DATA_NASCIMENTO) AS MAIS_NOVO_DE_IDADE
FROM TB_EMPREGADO
						)


-- TRABALHANDO COM AGRUPAMENTO POR DATA

-- FUNÇÕES DE DATA: SEPARAR ELEMENTOS DE UM CAMPO DE DATA

-- YEAR(CAMPO):	RETORNA O VALOR DO ANO DE UMA DATA
-- MONTH(CAMPO):	RETORNA O VALOR DO MÊS DE UMA DATA
-- DAY(CAMPO):		RETORNA O VALOR DO DIA DE UMA DATA

SELECT DATA_NASCIMENTO,
	YEAR(DATA_NASCIMENTO) AS ANO,
	MONTH(DATA_NASCIMENTO) AS MES,
	DAY(DATA_NASCIMENTO) AS DIA,
	NOME
FROM TB_EMPREGADO

-- EXEMPLO: CONTAR QUANTOS FUNCIONÁRIOS NASCERAM POR ANO
SELECT COUNT(*) AS QTDE,
	YEAR(DATA_NASCIMENTO) AS ANO_NASCIMENTO
FROM TB_EMPREGADO
GROUP BY	YEAR(DATA_NASCIMENTO)

-- EXERCICIO: DETERMINAR A SOMA DE VENDAS POR ANO E POR MES (AAAA/MM)
-- CONCAT (AAAA/MM)
SELECT SUM(VLR_TOTAL)		AS TOTAL_VENDA
, YEAR(DATA_EMISSAO)	AS ANO
, MONTH(DATA_EMISSAO) AS MES
, CONCAT(YEAR(DATA_EMISSAO) , '/' , MONTH(DATA_EMISSAO) ) AS ANO_MES
, LEN(MONTH(DATA_EMISSAO))
, CONCAT( YEAR(DATA_EMISSAO) , '/' , REPLICATE('0', 2 - LEN(MONTH(DATA_EMISSAO))) , MONTH(DATA_EMISSAO) )
FROM TB_PEDIDO
GROUP BY	YEAR(DATA_EMISSAO), 
			MONTH(DATA_EMISSAO), 
			CONCAT(YEAR(DATA_EMISSAO) , '/' , MONTH(DATA_EMISSAO) ),
			LEN(MONTH(DATA_EMISSAO)),
			REPLICATE('0', 2 - LEN(MONTH(DATA_EMISSAO))),
			CONCAT( YEAR(DATA_EMISSAO) , '/' , REPLICATE('0', 2 - LEN(MONTH(DATA_EMISSAO))) , MONTH(DATA_EMISSAO) )
ORDER BY	ANO_MES

--+ FUNÇÕES:
-- REPLICATE(VALOR, QTDE_VEZES): REPLICA O VALOR ESCOLHIDO, NA QUANTIDADE DE VEZES DETERMINADA

-- LEN(CAMPO) OU LENGHT(CAMPO): RETORNA A QUANTIDADE DE CARACTERES EXISTENTES EM UM DETERMINADO CAMPO

SELECT LEN('FABIANO H')

-- CONCATENANDO TEXTOS...
-- CONCAT( CAMPO1, CAMPO2, CAMPO3, ... , CAMPON)

-- EXEMPLO: CONCATENAR O VALOR "AAAA" NO CAMPO NOME DA TABELA DE EMPREGADOS

SELECT CONCAT('AAAA' , NOME)
FROM TB_EMPREGADO


-- EXERCICIO: DETERMINAR A SOMA DE VENDAS POR ANO E POR MES (AAAA/MM)
-- CONCAT (AAAA/MM)
SELECT SUM(VLR_TOTAL)		AS TOTAL_VENDA
, CONCAT( YEAR(DATA_EMISSAO) , '/' , REPLICATE('0', 2 - LEN(MONTH(DATA_EMISSAO))) , MONTH(DATA_EMISSAO) ) AS ANO_MES
FROM TB_PEDIDO
GROUP BY	CONCAT( YEAR(DATA_EMISSAO) , '/' , REPLICATE('0', 2 - LEN(MONTH(DATA_EMISSAO))) , MONTH(DATA_EMISSAO) )
ORDER BY	TOTAL_VENDA

-- EXERCICIO OPCIONAL:
-- MONTAR A ESTRUTURA DE ANO E MES (AAAA/MM) PARA OS CAMPOS DE DATA DA TABELA DE EMPREGADOS (NÁO PRECISA AGRUPAR)
USE pedidos
SELECT *
FROM TB_EMPREGADO

SELECT CONCAT( YEAR(DATA_NASCIMENTO) , '/' , REPLICATE('0', 2 - LEN(MONTH(DATA_NASCIMENTO))) , MONTH(DATA_NASCIMENTO) ) 	AS ANO_MES_NASCIMENTO,
	CONCAT( YEAR(DATA_ADMISSAO) , '/' , REPLICATE('0', 2 - LEN(MONTH(DATA_ADMISSAO))) , MONTH(DATA_ADMISSAO) ) 				AS ANO_MES_ADMISSAO
FROM TB_EMPREGADO
GROUP BY	CONCAT( YEAR(DATA_NASCIMENTO) , '/' , REPLICATE('0', 2 - LEN(MONTH(DATA_NASCIMENTO))) , MONTH(DATA_NASCIMENTO)),
					CONCAT( YEAR(DATA_ADMISSAO) , '/' , REPLICATE('0', 2 - LEN(MONTH(DATA_ADMISSAO))) , MONTH(DATA_ADMISSAO))
-- EXERCICIO DE PRESENÇA:
-- 1. RETORNAR A QUANTIDADE (CONTAGEM) DE VENDAS POR CODCLI (TB_PEDIDO)
SELECT COUNT(*) AS QTDE_VENDAS,
	CODCLI
FROM TB_PEDIDO
GROUP BY	CODCLI
-- 2. RETORNAR A MÉDIA DE VENDAS POR CODIGO DA COR (TB_ITENSPEDIDO)
SELECT *
FROM TB_ITENSPEDIDO

SELECT AVG(NUM_PEDIDO) AS MEDIA_VENDAS,
	CODCOR
FROM TB_ITENSPEDIDO
GROUP BY	CODCOR

-- 3. RETORNAR A SOMA DE VENDAS POR VENDEDOR E POR ANO (TB_PEDIDO)
SELECT *
FROM TB_PEDIDO

SELECT SUM(VLR_TOTAL) AS SOMA_VENDAS,
	CODVEN,
	YEAR(DATA_EMISSAO) AS ANO_VENDA
FROM TB_PEDIDO
GROUP BY	CODVEN, YEAR(DATA_EMISSAO)

-- Aula do dia 07/04/2020

-- AC02:

-- UTILIZANDO O BANCO DE DADOS PEDIDOS, EXECUTAR OS EXERCÍCIOS ABAIXO:

--1. SELECIONAR OS DEPENDENTES QUE TERMINEM O NOME COM ALGUMA VOGAL
USE PEDIDOS
SELECT * FROM TB_DEPENDENTE

SELECT		*
FROM		TB_DEPENDENTE
WHERE		NOME LIKE '%[AEIOU]'

--2. RETORNAR A QUANTIDADE DE FORNECEDORES POR CIDADE, QUE CONTENHAM "LTDA" OU "COM" OU "IND" EM SEU NOME
SELECT TOP 3 * FROM TB_FORNECEDOR

SELECT		CIDADE,
			COUNT(*) AS QTDE
FROM		TB_FORNECEDOR
WHERE		NOME LIKE '%LTDA%'	OR 
			NOME LIKE '%COM%'	OR
			NOME LIKE '%IND%'
GROUP BY	CIDADE
ORDER BY	QTDE DESC

--3. CONFIGURAR O CEP DOS FORNECEDORES PARA RETORNAR NO FORMATO: "CEP: NN.NNN-NNN"

SELECT TOP 3 * FROM TB_FORNECEDOR

-- VALIDAÇÃO DE TAMANHO DO CAMPO PREENCHIDO
SELECT CEP, LEN(CEP) AS COMPRIMENTO
FROM TB_FORNECEDOR
ORDER BY COMPRIMENTO 

SELECT		CEP,
			LEFT(CEP, 2)			AS DOIS_A_ESQUERDA,
			SUBSTRING(CEP, 3, 3)	AS DIGITOS_3_A_5,
			RIGHT(CEP, 4)			AS TRES_A_DIREITA,
			CONCAT	(
						LEFT(CEP, 2) ,
						'.',
						SUBSTRING(CEP, 3, 3),
						'-',
						RIGHT(CEP, 4)
					) AS CEP_COM_MASCARA
FROM		TB_FORNECEDOR
WHERE		LEN(CEP) = 8

--4. RETORNAR A SOMA DE SALÁRIOS POR DEPARTAMENTO E POR CARGO
SELECT * FROM TB_EMPREGADO

SELECT		SUM(SALARIO)		AS TOTAL_SALARIO,
			COD_DEPTO,
			COD_CARGO
FROM		TB_EMPREGADO
GROUP BY	COD_DEPTO,
			COD_CARGO

SELECT		SUM(SALARIO)		AS TOTAL_SALARIO,
			COD_DEPTO		
FROM		TB_EMPREGADO
GROUP BY	COD_DEPTO
SELECT		SUM(SALARIO)		AS TOTAL_SALARIO,
			COD_CARGO
FROM		TB_EMPREGADO
GROUP BY	COD_CARGO

--5. DETERMINAR QUAL O CLIENTE MAIS ANTIGO E QUAL O CLIENTE O MAIS NOVO

SELECT	TOP 3 * FROM TB_CLIENTE

SELECT MAX(DATA_CAD) AS MAXIMA_DATA
FROM	TB_CLIENTE

SELECT * FROM TB_CLIENTE
WHERE	DATA_CAD = '1997-22-10'

SELECT * FROM TB_CLIENTE
WHERE	DATA_CAD = (SELECT MAX(DATA_CAD) AS MAXIMA_DATA
					FROM	TB_CLIENTE)
--CLIENTE MAIS NOVO: PROGERAL IND. DE ARTEFATOS PLASTICOS LTDA.

-- OUTRA FORMA DE FAZER: COM ORDER BY + TOP N + WITH TIES
SELECT TOP 1 WITH TIES *
FROM	TB_CLIENTE
WHERE	DATA_CAD IS NOT NULL
ORDER BY DATA_CAD DESC

SELECT MIN(DATA_CAD) AS MAXIMA_DATA
FROM	TB_CLIENTE

SELECT * FROM TB_CLIENTE
WHERE	DATA_CAD = '1997-06-02'

SELECT * FROM TB_CLIENTE
WHERE	DATA_CAD = (SELECT MIN(DATA_CAD) AS MAXIMA_DATA
					FROM	TB_CLIENTE)

-- OUTRA FORMA DE FAZER: COM ORDER BY + TOP N + WITH TIES
SELECT TOP 1 WITH TIES *
FROM	TB_CLIENTE
WHERE	DATA_CAD IS NOT NULL
ORDER BY DATA_CAD ASC

-- CLIENTES MAIS VELHOS: 
--AUGUSTO'S FOLHINHAS LTDA
--ASSIS BRINDES COMERCIO INDUSTRIA LTDA
--AVEL APOLIMARIO VEICULOS S.A
--ANTONIO M.DE SOUZA
--ARISTON SERIGRAFIA ESTRUT.ART.PLAST.LTDA.-ME
--APLIKE SERIGRAFIA LTDA


--6. DETERMINAR A SOMA DE VENDAS POR ANO E POR MES (AAAA/MM) NA TABELA DE PEDIDOS

SELECT		SUM(VLR_TOTAL)		AS TOTAL_VENDA,
			YEAR(DATA_EMISSAO)	AS ANO,
			MONTH(DATA_EMISSAO)	AS MES
FROM		TB_PEDIDO
GROUP BY	YEAR(DATA_EMISSAO)	,
			MONTH(DATA_EMISSAO)
ORDER BY	TOTAL_VENDA

SELECT		SUM(VLR_TOTAL)		AS TOTAL_VENDA,
			YEAR(DATA_EMISSAO)	AS ANO,
			MONTH(DATA_EMISSAO)	AS MES,
			CONCAT ( YEAR(DATA_EMISSAO)	, '/' , MONTH(DATA_EMISSAO)	) AS ANO_MES --(AAAA/MM OU AAAA/M)
FROM		TB_PEDIDO
GROUP BY	YEAR(DATA_EMISSAO)	,
			MONTH(DATA_EMISSAO) ,
			CONCAT ( YEAR(DATA_EMISSAO)	, '/' , MONTH(DATA_EMISSAO)	)
ORDER BY	TOTAL_VENDA

SELECT		SUM(VLR_TOTAL)		AS TOTAL_VENDA
,			CONCAT( YEAR(DATA_EMISSAO) , '/' , REPLICATE('0', 2 - LEN(MONTH(DATA_EMISSAO))) , MONTH(DATA_EMISSAO) ) AS ANO_MES
FROM		TB_PEDIDO
GROUP BY	CONCAT( YEAR(DATA_EMISSAO) , '/' , REPLICATE('0', 2 - LEN(MONTH(DATA_EMISSAO))) , MONTH(DATA_EMISSAO) )
ORDER BY	TOTAL_VENDA

-- EXPLICANDO O REPLICATE
--10: PARA O MÊS COM DOIS DIGITOS, NÃO INSERE NADA
--9 : PARA O MÊS COM UM DIGITO, INSERE UM '0' A ESQUERDA

--7. RETORNAR O TOP 3 VENDEDORES QUE POSSUEM MAIOR MÉDIA DE VENDAS (RANKING: TOP N + ORDER BY)

SELECT TOP 3 * FROM TB_PEDIDO

SELECT			TOP 3 WITH TIES
				AVG(VLR_TOTAL)	AS MEDIA_VENDAS,
				CODVEN

FROM			TB_PEDIDO
GROUP BY		CODVEN
ORDER BY		MEDIA_VENDAS DESC



--8. INSERIR O TOTAL DE VENDAS QUE O VENDEDOR FEZ POR CLIENTE (OBJETIVO: SABER QUAL VENDEDOR MAIS FIDELIZA CLIENTES)

SELECT TOP 3 * FROM TB_PEDIDO

SELECT		SUM(VLR_TOTAL)		AS TOTAL_VENDA,
			CODVEN,
			CODCLI

FROM		TB_PEDIDO
GROUP BY	CODVEN,
			CODCLI
ORDER BY	TOTAL_VENDA DESC

SELECT		COUNT(CODVEN) AS TOTAL_VENDA,
			CODVEN,
			CODCLI

FROM		TB_PEDIDO
GROUP BY	CODVEN,
			CODCLI
ORDER BY	TOTAL_VENDA DESC

SELECT TOP 3 * FROM TB_EMPREGADO

SELECT TOP 3 * FROM TB_DEPENDENTE

SELECT *

FROM			TB_EMPREGADO, TB_DEPENDENTE

--QUANDO NÃO CRIO UM RELACIONAMENTO, ELE TRAZ A MULTIPLICAÇÃO DE UMA TABELA PELA OUTRA.
-- EXEMPLO: BUSCAR OS DEPENDENTES DE CADA FUNCIONÁRIOS (NOME DO FUNCIONÁRIO E DO DEPENDENTE )
-- OBS.: DESTA VEZ EU CRIO O RELACIONAMENTO
SELECT *

FROM			TB_EMPREGADO, TB_DEPENDENTE
WHERE			TB_EMPREGADO.CODFUN = TB_DEPENDENTE.CODFUN

-- SIMPLIFICANDO ESTA CONSULTA, E TRAZENDO O NOME DOS DOIS E SALARIO DO FUNCIONARIO
SELECT		TB_EMPREGADO.NOME,
					TB_DEPENDENTE.NOME,
					TB_EMPREGADO.SALARIO
FROM			TB_EMPREGADO, TB_DEPENDENTE
WHERE			TB_EMPREGADO.CODFUN = TB_DEPENDENTE.CODFUN

-- EXERCICIO: BUSCAR O NOME DO FUNCIONARIO, SEU SALARIO ATUAL E SEU SALARIO INICIAL 
SELECT		TB_EMPREGADO.NOME,
					TB_EMPREGADO.SALARIO AS SALARIO_ATUAL,
					TB_CARGO.SALARIO_INIC,
					TB_CARGO.CARGO

FROM			TB_EMPREGADO, TB_CARGO
WHERE			TB_EMPREGADO.COD_CARGO = TB_CARGO.COD_CARGO
-- SIMPLIFICANDO O CODIGO: INSERINDO ALIAS PARA AS TABELAS
SELECT		EMP.NOME,
					EMP.SALARIO AS SALARIO_ATUAL,
					CRG.SALARIO_INIC,
					CRG.CARGO

FROM			TB_EMPREGADO		AS EMP, 
					TB_CARGO				AS CRG
WHERE			EMP.COD_CARGO = CRG.COD_CARGO

-- EXERCICIO: SELECIONAR OS NOMES DOS COLABOLADORES E SEUS DEPENDENTES

SELECT		EMP.NOME AS NOME,
					DEP.DEPTO AS DEPARTAMENTO

FROM			TB_EMPREGADO AS EMP,
					TB_DEPARTAMENTO AS DEP
WHERE			EMP.COD_DEPTO = DEP.COD_DEPTO

-- EXERCICIO: TRAZER OS NOMES DOS FUNCIONARIOS, NOMES DOS DEPARTAMENTOS E NOMES DOS DEPENDENTES

SELECT			EMP.NOME,
						DEP.DEPTO AS DEPARTAMENTO,
						DPD.NOME AS DEPENDENTE
FROM				TB_EMPREGADO			AS EMP,
						TB_DEPARTAMENTO		AS DEP,
						TB_DEPENDENTE			AS DPD
WHERE				EMP.COD_DEPTO = DEP.COD_DEPTO
AND					EMP.CODFUN = DPD.CODFUN

SELECT TOP 3 * FROM TB_DEPENDENTE
SELECT TOP 3 * FROM TB_EMPREGADO

-- EXERCICIO: TRAZER OS VALORES DE PEDIDOS COM OS NOMES DOS VENDEDORES APENAS DE PEDIDOS FEITOS NO MES DE FEVEREIRO
SELECT			PDD.VLR_TOTAL,
						VDD.NOME,
						PDD.DATA_EMISSAO
FROM				TB_PEDIDO				AS PDD,
						TB_VENDEDOR			AS VDD
WHERE				PDD.CODVEN = VDD.CODVEN
AND					MONTH(DATA_EMISSAO) = 02
-- A PARTIR DA PRÓXIMA AULA: EU TRANSFORMO O SELECT COM MAIS UMA TABELA EM UMA JUNÇÃO (JOIN)
--BUSCAR POR NOME DO SEU EMPREGADO E DO SEU DEPENDENTE
SELECT		EMP.NOME,
					DEP.NOME
FROM			TB_EMPREGADO AS EMP, TB_DEPENDENTE AS DEP
WHERE			EMP.CODFUN = DEP.CODFUN

-- OUTRA FORMA: UTILIZANDO O JOIN
SELECT		EMP.NOME,
					DEP.NOME

FROM				TB_EMPREGADO AS EMP
INNER JOIN	TB_DEPENDENTE AS DEP
ON					EMP.CODFUN = DEP.CODFUN

-- Aula de Reposição do dia 09/04/2020

SELECT *
FROM TB_CLIENTE
WHERE  CIDADE IN ('MARILIA', 'ASSIS')

SELECT *
FROM TB_PEDIDO
WHERE CODCLI IN (3, 4, 176, 251, 302, 373, 397, 556)

-- COM SUBQUERY

SELECT *
FROM TB_PEDIDO
WHERE CODCLI IN (
									SELECT CODCLI FROM TB_CLIENTE
									WHERE CIDADE IN ('MARILIA', 'ASSIS')
)
-- TROCAR O COMANDO ACIMA POR UM JOIN 

SELECT PED.*
FROM TB_CLIENTE AS CLI,
     TB_PEDIDO AS PED
WHERE CLI.CODCLI = PED.CODCLI
AND CLI.CIDADE IN ('MARILIA', 'ASSIS')


SELECT * FROM TB_EMPREGADO
WHERE COD_CARGO IN (
											SELECT COD_CARGO FROM TB_CARGO
											WHERE SALARIO <= 3000
)
-- TROCAR O COMANDO ACIMA POR UM JOIN (SELECT COM DUAS TABELAS NA CLÁUSULA FROM)
SELECT	EMP.*

FROM		[DBO].[TB_CARGO]				AS CRG,
				[DBO].[TB_EMPREGADO]		AS EMP

WHERE		CRG.COD_CARGO = EMP.COD_CARGO
AND			CRG.SALARIO_INIC < 3000


SELECT * FROM TB_EMPREGADO
WHERE COD_DEPTO IN (
										SELECT COD_DEPTO FROM TB_DEPARTAMENTO
										WHERE DEPTO LIKE '%[AEIOU]'
)
-- #########################

SELECT * FROM TB_EMPREGADO
WHERE EXISTS (
								SELECT * FROM TB_DEPARTAMENTO
								WHERE DEPTO LIKE '%[AEIOU]'
								AND COD_DEPTO = TB_EMPREGADO.COD_DEPTO
)


SELECT * 
FROM TB_DEPARTAMENTO
WHERE COD_DEPTO NOT IN (
													SELECT DISTINCT COD_DEPTO 
													FROM TB_EMPREGADO
													WHERE COD_DEPTO IS NOT NULL
)

 

-- FUNÇÃO: CASE
SELECT NOME,
			SALARIO,
			SINDICALIZADO,
			CASE SINDICALIZADO
					WHEN 'S' THEN 'SIM'
					WHEN 'N' THEN 'NÃO' 
					ELSE 'N/C'
			END AS SITUACAO,
			DATA_ADMISSAO
FROM TB_EMPREGADO

SELECT 	NOME,
				CASE		ESTADO
						WHEN 'SP' THEN 'SÃO PAULO'
						WHEN 'PR' THEN 'PARANÁ'
						ELSE 'OUTROS ESTADOS'
				END AS ESTADO_MANIPULADO
FROM TB_CLIENTE

-- TRAZER O NOME DO CLIENTE + UMA VALIDAÇÃO DO MÊS DE CADASTRO E A PARTIR DIST. ME INSERIR O NOME POR EXTENSO

SELECT 
CONCAT(REPLICATE('0', 2 - LEN(MONTH(DATA_CAD))) , MONTH(DATA_CAD) ) AS ANO_MES 
FROM TB_CLIENTE

SELECT		NOME,
					CONCAT(REPLICATE('0', 2 - LEN(MONTH(DATA_CAD))) , MONTH(DATA_CAD) ) AS MES,
					CASE			MONTH(DATA_CAD)
							WHEN '01' THEN 'JANEIRO'
							WHEN '02' THEN 'FEVEREIRO'
							WHEN '03' THEN 'MARÇO'
							WHEN '04' THEN 'ABRIL'
							WHEN '05' THEN 'MAIO'
							WHEN '06' THEN 'JUNHO'
							WHEN '07' THEN 'JULHO'
							WHEN '08' THEN 'AGOSTO'
							WHEN '09' THEN 'SETEMBRO'
							WHEN '10' THEN 'OUTUBRO'
							WHEN '11' THEN 'NOVEMBRO'
							WHEN '12' THEN 'DEZEMBRO'
							ELSE 'VAZIO'
					END AS MES_EXTENSO
FROM			TB_CLIENTE

--RESOLVER OS EXERCÍCIOS ABAIXO COM SUBQUERY:

--1. SELECIONAR CLIENTES QUE COMPRARAM EM JANEIRO DE 2014
SELECT NOME FROM TB_CLIENTE
WHERE EXISTS (
									SELECT YEAR(DATA_EMISSAO) FROM TB_PEDIDO
									WHERE YEAR(DATA_EMISSAO) = 2014
									AND CODCLI = TB_CLIENTE.CODCLI
)

--2.LISTAR OS CARGOS EM QUE NÃO EXISTA NENHUM FUNCIONÁRIO CADASTRADO
SELECT CARGO 
FROM TB_CARGO
WHERE COD_CARGO NOT IN (
													SELECT DISTINCT COD_CARGO 
													FROM TB_EMPREGADO
													WHERE COD_CARGO IS NOT NULL
)

--3. QUAIS SÃO OS FUNCIONÁRIOS QUE GANHAM MENOS?

SELECT * 
FROM TB_EMPREGADO
WHERE CODCLI IN (
									SELECT *
									FROM TB_PEDIDO
)

--4. QUAL O FUNCIONÁRIO COM MAIOR PREMIO MENSAL?

--4. SELECIONAR CLIENTES QUE COMPRARAM EM JANEIRO DE 2014
-- 1º: ACHAR QUAIS SÃO AS COMPRAS DE JANEIRO DE 2014
-- 2º: A PARTIR DA LISTA DE CODCLIS ENCONTRADOS, UTILIZAR A TABELA DE CLIENTES PARA SABER OS NOMES DELES
SELECT	TOP 3 * FROM TB_PEDIDO
SELECT	TOP 3 * FROM TB_CLIENTE

SELECT	CODCLI
FROM	TB_PEDIDO
WHERE	DATA_EMISSAO BETWEEN '2014-01-01' AND '2014-31-01'
ORDER BY CODCLI

SELECT	*
FROM	TB_CLIENTE
WHERE	CODCLI IN	(	
						SELECT	CODCLI
						FROM	TB_PEDIDO
						WHERE	DATA_EMISSAO BETWEEN '2014-01-01' AND '2014-31-01' 
					)

SELECT	*
FROM	TB_CLIENTE
WHERE	CODCLI IN	(	
						SELECT	CODCLI
						FROM	TB_PEDIDO
						WHERE	YEAR(DATA_EMISSAO) = 2014 
						  AND	MONTH(DATA_EMISSAO) = 01  
					)

SELECT		CLI.NOME, 
			PED.CODCLI, 
			PED.DATA_EMISSAO 
FROM		TB_PEDIDO PED, 
			TB_CLIENTE CLI
WHERE		PED.CODCLI = CLI.CODCLI 
AND			MONTH(DATA_EMISSAO) = 01 
AND			YEAR(DATA_EMISSAO) = 2014 
ORDER BY CODCLI